#!/usr/bin/env python3
"""
Image Description Toolkit - Windows GUI Application

A comprehensive GUI wrapper for the Image Description Toolkit that provides
an accessible, user-friendly interface for AI-powered image analysis.

This application wraps the existing command-line scripts:
- image_describer.py - AI-powered image analysis
- descriptions_to_html.py - HTML gallery generation
- ConvertImage.py - HEIC to JPG conversion

Features:
- Full Windows accessibility support (screen readers, keyboard navigation)
- Drag-and-drop file selection
- Real-time progress tracking
- Batch processing capabilities
- Settings management
- HTML preview functionality
"""

import sys
import os
import json
import threading
import time
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime

# PyQt6 imports
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QGridLayout, QTabWidget, QLabel, QPushButton, QLineEdit, 
    QTextEdit, QProgressBar, QFileDialog, QMessageBox, QComboBox,
    QSpinBox, QCheckBox, QGroupBox, QSplitter, QTreeWidget, 
    QTreeWidgetItem, QListWidget, QListWidgetItem, QScrollArea,
    QFrame, QMenuBar, QStatusBar, QSlider, QButtonGroup, QRadioButton
)
from PyQt6.QtCore import (
    Qt, QThread, QTimer, pyqtSignal, QSettings, QStandardPaths,
    QUrl, QSize, QRect
)
from PyQt6.QtGui import (
    QPixmap, QIcon, QFont, QKeySequence, QShortcut, QDesktopServices,
    QDragEnterEvent, QDropEvent, QAction, QPalette, QColor, QTextCursor
)

# Import our existing modules
try:
    from image_describer import ImageDescriber
    from html_converter import DescriptionsToHTML
    from ConvertImage import convert_heic_to_jpg, convert_directory
except ImportError as e:
    print(f"Error importing modules: {e}")
    print("Please ensure all required modules are in the same directory")
    sys.exit(1)


class ProcessingThread(QThread):
    """Thread for background image processing"""
    
    progress_updated = pyqtSignal(int, str)  # progress, status message
    processing_complete = pyqtSignal(bool, str)  # success, message
    image_processed = pyqtSignal(str, str)  # filename, description
    
    def __init__(self, folder_path: str, model_name: str, prompt_style: str, 
                 recursive: bool = False, max_size: int = 1024, batch_delay: float = 2.0):
        super().__init__()
        self.folder_path = folder_path
        self.model_name = model_name
        self.prompt_style = prompt_style
        self.recursive = recursive
        self.max_size = max_size
        self.batch_delay = batch_delay
        self.should_stop = False
        
    def run(self):
        try:
            # Create ImageDescriber instance
            describer = ImageDescriber(
                model_name=self.model_name,
                prompt_style=self.prompt_style,
                max_image_size=self.max_size,
                batch_delay=self.batch_delay
            )
            
            # Get folder path
            folder_path = Path(self.folder_path)
            
            # Get all image files first for progress tracking
            pattern = "**/*" if self.recursive else "*"
            image_files = []
            
            for file_path in folder_path.glob(pattern):
                if file_path.is_file() and describer.is_supported_image(file_path):
                    image_files.append(file_path)
            
            if not image_files:
                self.processing_complete.emit(False, "No supported image files found")
                return
            
            total_images = len(image_files)
            self.progress_updated.emit(0, f"Found {total_images} images to process")
            
            # Create output file path
            output_file = folder_path / "image_descriptions.txt"
            
            # Initialize the output file with a header
            try:
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write("Image Descriptions Generated by Ollama Vision Model\n")
                    f.write("=" * 80 + "\n")
                    f.write(f"Generated on: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"Model used: {self.model_name}\n")
                    f.write(f"Prompt style: {self.prompt_style}\n")
                    f.write(f"Directory: {folder_path}\n")
                    f.write("=" * 80 + "\n\n")
            except Exception as e:
                self.processing_complete.emit(False, f"Error creating output file: {str(e)}")
                return
            
            # Process each image
            success_count = 0
            for i, image_path in enumerate(image_files):
                if self.should_stop:
                    break
                    
                self.progress_updated.emit(
                    int((i / total_images) * 100),
                    f"Processing {image_path.name}..."
                )
                
                try:
                    # Extract metadata from image
                    metadata = describer.extract_metadata(image_path)
                    
                    # Get description from Ollama
                    description = describer.get_image_description(image_path)
                    
                    if description:
                        # Write description to file with metadata
                        if describer.write_description_to_file(image_path, description, output_file, metadata):
                            success_count += 1
                            self.image_processed.emit(str(image_path), description)
                        else:
                            self.image_processed.emit(str(image_path), "Failed to write description")
                    else:
                        self.image_processed.emit(str(image_path), "Failed to generate description")
                        
                except Exception as e:
                    self.progress_updated.emit(
                        int((i / total_images) * 100),
                        f"Error processing {image_path.name}: {str(e)}"
                    )
                    self.image_processed.emit(str(image_path), f"Error: {str(e)}")
                    continue
                    
                # Add delay between images
                if self.batch_delay > 0 and not self.should_stop:
                    time.sleep(self.batch_delay)
                    
            if not self.should_stop:
                self.processing_complete.emit(
                    True, 
                    f"Successfully processed {success_count} of {total_images} images. Results saved to {output_file.name}"
                )
            else:
                self.processing_complete.emit(False, "Processing cancelled by user")
                
        except Exception as e:
            self.processing_complete.emit(False, f"Processing failed: {str(e)}")
    
    def stop(self):
        self.should_stop = True


class HEICConversionThread(QThread):
    """Thread for HEIC to JPG conversion"""
    
    progress_updated = pyqtSignal(int, str)
    conversion_complete = pyqtSignal(bool, str)
    
    def __init__(self, input_paths: List[str], output_dir: str, quality: int = 95):
        super().__init__()
        self.input_paths = input_paths
        self.output_dir = output_dir
        self.quality = quality
        self.should_stop = False
        
    def run(self):
        try:
            total_files = len(self.input_paths)
            converted_count = 0
            
            for i, input_path in enumerate(self.input_paths):
                if self.should_stop:
                    break
                    
                self.progress_updated.emit(
                    int((i / total_files) * 100),
                    f"Converting {Path(input_path).name}..."
                )
                
                try:
                    output_path = Path(self.output_dir) / f"{Path(input_path).stem}.jpg"
                    success = convert_heic_to_jpg(input_path, output_path, self.quality)
                    if success:
                        converted_count += 1
                        
                except Exception as e:
                    self.progress_updated.emit(
                        int((i / total_files) * 100),
                        f"Error converting {Path(input_path).name}: {str(e)}"
                    )
                    continue
                    
            if not self.should_stop:
                self.conversion_complete.emit(
                    True, 
                    f"Successfully converted {converted_count} of {total_files} files"
                )
            else:
                self.conversion_complete.emit(False, "Conversion cancelled by user")
                
        except Exception as e:
            self.conversion_complete.emit(False, f"Conversion failed: {str(e)}")
    
    def stop(self):
        self.should_stop = True


class ImageDescriptionGUI(QMainWindow):
    """Main GUI application window"""
    
    def __init__(self):
        super().__init__()
        self.processing_thread = None
        self.conversion_thread = None
        self.settings = QSettings('ImageDescriptionToolkit', 'ImageDescriptionToolkit')
        
        self.init_ui()
        self.load_settings()
        self.setup_accessibility()
        
    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("Image Description Toolkit")
        self.setGeometry(100, 100, 1200, 800)
        
        # Create central widget and main layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Create tab widget
        self.tabs = QTabWidget()
        central_widget_layout = QVBoxLayout(central_widget)
        central_widget_layout.addWidget(self.tabs)
        
        # Create tabs
        self.create_image_processing_tab()
        self.create_heic_conversion_tab()
        self.create_html_gallery_tab()
        self.create_settings_tab()
        
        # Load configuration after all UI elements are created
        self.load_config_to_ui()
        
        # Connect UI elements to immediately update QSettings
        self.connect_settings_signals()
        
        # Create menu bar
        self.create_menu_bar()
        
        # Create status bar
        self.create_status_bar()
        
    def connect_settings_signals(self):
        """Connect UI elements to immediately update QSettings when values change"""
        # Settings tab controls
        self.model_combo.currentTextChanged.connect(self.update_model_setting)
        self.default_prompt_combo.currentTextChanged.connect(self.update_prompt_setting)
        self.recursive_check.toggled.connect(self.update_recursive_setting)
        self.default_max_size_spin.valueChanged.connect(self.update_max_size_setting)
        self.default_batch_delay_spin.valueChanged.connect(self.update_batch_delay_setting)
        self.quality_slider.valueChanged.connect(self.update_quality_setting)
        self.html_full_details.toggled.connect(self.update_html_details_setting)
        
    def update_model_setting(self, value):
        """Update model setting in QSettings immediately"""
        self.settings.setValue('model', value)
        self.settings.sync()
        
    def update_prompt_setting(self, value):
        """Update prompt setting in QSettings immediately"""
        self.settings.setValue('prompt_style', value)
        self.settings.sync()
        
    def update_recursive_setting(self, value):
        """Update recursive setting in QSettings immediately"""
        self.settings.setValue('recursive', value)
        self.settings.sync()
        
    def update_max_size_setting(self, value):
        """Update max size setting in QSettings immediately"""
        self.settings.setValue('max_size', value)
        self.settings.sync()
        
    def update_batch_delay_setting(self, value):
        """Update batch delay setting in QSettings immediately"""
        self.settings.setValue('batch_delay', value)
        self.settings.sync()
        
    def update_quality_setting(self, value):
        """Update quality setting in QSettings immediately"""
        self.settings.setValue('jpeg_quality', value)
        self.settings.sync()
        
    def update_html_details_setting(self, value):
        """Update HTML details setting in QSettings immediately"""
        self.settings.setValue('html_full_details', value)
        self.settings.sync()
        
    def create_menu_bar(self):
        """Create the application menu bar"""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu('&File')
        
        # Open folder action
        open_folder_action = QAction('&Open Folder...', self)
        open_folder_action.setShortcut(QKeySequence.StandardKey.Open)
        open_folder_action.setStatusTip('Open folder containing images')
        open_folder_action.triggered.connect(self.select_image_folder)
        file_menu.addAction(open_folder_action)
        
        file_menu.addSeparator()
        
        # Exit action
        exit_action = QAction('E&xit', self)
        exit_action.setShortcut(QKeySequence.StandardKey.Quit)
        exit_action.setStatusTip('Exit application')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Help menu
        help_menu = menubar.addMenu('&Help')
        
        # About action
        about_action = QAction('&About', self)
        about_action.setStatusTip('About Image Description Toolkit')
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
        
    def create_status_bar(self):
        """Create the status bar"""
        self.status_bar = self.statusBar()
        self.status_bar.showMessage('Ready')
        
    def create_image_processing_tab(self):
        """Create the main image processing tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # File selection section
        file_group = QGroupBox("Image Selection")
        file_layout = QVBoxLayout(file_group)
        
        # Folder selection
        folder_layout = QHBoxLayout()
        self.folder_path = QLineEdit()
        self.folder_path.setPlaceholderText("Select folder containing images...")
        self.folder_path.setAccessibleName("Image Folder Path")
        self.folder_path.setAccessibleDescription("Path to folder containing images to process")
        
        self.browse_button = QPushButton("Browse...")
        self.browse_button.setAccessibleName("Browse for Image Folder")
        self.browse_button.setAccessibleDescription("Click to select folder containing images")
        self.browse_button.clicked.connect(self.select_image_folder)
        
        folder_layout.addWidget(QLabel("Image Folder:"))
        folder_layout.addWidget(self.folder_path)
        folder_layout.addWidget(self.browse_button)
        file_layout.addLayout(folder_layout)
        
        # Recursive processing checkbox
        self.recursive_check = QCheckBox("Process subdirectories recursively")
        self.recursive_check.setAccessibleName("Recursive Processing")
        self.recursive_check.setAccessibleDescription("Check to process images in subdirectories")
        file_layout.addWidget(self.recursive_check)
        
        layout.addWidget(file_group)
        
        # Note: Processing options moved to Settings tab to avoid duplication
        
        # Processing controls
        controls_layout = QHBoxLayout()
        
        self.process_button = QPushButton("Start Processing")
        self.process_button.setAccessibleName("Start Image Processing")
        self.process_button.setAccessibleDescription("Click to start processing images with AI description")
        self.process_button.clicked.connect(self.start_processing)
        
        self.stop_button = QPushButton("Stop Processing")
        self.stop_button.setAccessibleName("Stop Image Processing")
        self.stop_button.setAccessibleDescription("Click to stop the current processing operation")
        self.stop_button.clicked.connect(self.stop_processing)
        self.stop_button.setEnabled(False)
        
        controls_layout.addWidget(self.process_button)
        controls_layout.addWidget(self.stop_button)
        controls_layout.addStretch()
        
        layout.addLayout(controls_layout)
        
        # Progress section
        progress_group = QGroupBox("Processing Progress")
        progress_layout = QVBoxLayout(progress_group)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setAccessibleName("Processing Progress")
        self.progress_bar.setAccessibleDescription("Shows progress of image processing")
        progress_layout.addWidget(self.progress_bar)
        
        self.status_label = QLabel("Ready to process images")
        self.status_label.setAccessibleName("Processing Status")
        progress_layout.addWidget(self.status_label)
        
        layout.addWidget(progress_group)
        
        # Results section
        results_group = QGroupBox("Processing Results")
        results_layout = QVBoxLayout(results_group)
        
        self.results_text = QTextEdit()
        self.results_text.setAccessibleName("Processing Results")
        self.results_text.setAccessibleDescription("Shows results and status messages from image processing")
        self.results_text.setReadOnly(True)
        self.results_text.setTabChangesFocus(True)  # Enable Tab navigation
        results_layout.addWidget(self.results_text)
        
        layout.addWidget(results_group)
        
        self.tabs.addTab(tab, "Image Processing")
        
    def create_heic_conversion_tab(self):
        """Create the HEIC conversion tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # File selection section
        file_group = QGroupBox("HEIC File Selection")
        file_layout = QVBoxLayout(file_group)
        
        # Input folder selection
        input_layout = QHBoxLayout()
        self.heic_input_path = QLineEdit()
        self.heic_input_path.setPlaceholderText("Select folder containing HEIC files...")
        self.heic_input_path.setAccessibleName("HEIC Input Folder Path")
        self.heic_input_path.setAccessibleDescription("Path to folder containing HEIC files to convert")
        
        self.heic_browse_button = QPushButton("Browse...")
        self.heic_browse_button.setAccessibleName("Browse for HEIC Folder")
        self.heic_browse_button.setAccessibleDescription("Click to select folder containing HEIC files")
        self.heic_browse_button.clicked.connect(self.select_heic_folder)
        
        input_layout.addWidget(QLabel("HEIC Folder:"))
        input_layout.addWidget(self.heic_input_path)
        input_layout.addWidget(self.heic_browse_button)
        file_layout.addLayout(input_layout)
        
        # Output folder selection
        output_layout = QHBoxLayout()
        self.heic_output_path = QLineEdit()
        self.heic_output_path.setPlaceholderText("Select output folder for JPG files...")
        self.heic_output_path.setAccessibleName("JPG Output Folder Path")
        self.heic_output_path.setAccessibleDescription("Path to folder where converted JPG files will be saved")
        
        self.heic_output_browse_button = QPushButton("Browse...")
        self.heic_output_browse_button.setAccessibleName("Browse for Output Folder")
        self.heic_output_browse_button.setAccessibleDescription("Click to select output folder for JPG files")
        self.heic_output_browse_button.clicked.connect(self.select_heic_output_folder)
        
        output_layout.addWidget(QLabel("Output Folder:"))
        output_layout.addWidget(self.heic_output_path)
        output_layout.addWidget(self.heic_output_browse_button)
        file_layout.addLayout(output_layout)
        
        layout.addWidget(file_group)
        
        # Conversion options
        options_group = QGroupBox("Conversion Options")
        options_layout = QGridLayout(options_group)
        
        # Quality setting
        options_layout.addWidget(QLabel("JPEG Quality:"), 0, 0)
        self.quality_slider = QSlider(Qt.Orientation.Horizontal)
        self.quality_slider.setRange(1, 100)
        self.quality_slider.setValue(95)
        self.quality_slider.setAccessibleName("JPEG Quality")
        self.quality_slider.setAccessibleDescription("Set the quality of converted JPG files (1-100)")
        self.quality_slider.valueChanged.connect(self.update_quality_label)
        
        self.quality_label = QLabel("95")
        self.quality_label.setAccessibleName("Quality Value")
        
        options_layout.addWidget(self.quality_slider, 0, 1)
        options_layout.addWidget(self.quality_label, 0, 2)
        
        layout.addWidget(options_group)
        
        # Conversion controls
        controls_layout = QHBoxLayout()
        
        self.convert_button = QPushButton("Start Conversion")
        self.convert_button.setAccessibleName("Start HEIC Conversion")
        self.convert_button.setAccessibleDescription("Click to start converting HEIC files to JPG")
        self.convert_button.clicked.connect(self.start_heic_conversion)
        
        self.stop_convert_button = QPushButton("Stop Conversion")
        self.stop_convert_button.setAccessibleName("Stop HEIC Conversion")
        self.stop_convert_button.setAccessibleDescription("Click to stop the current conversion operation")
        self.stop_convert_button.clicked.connect(self.stop_heic_conversion)
        self.stop_convert_button.setEnabled(False)
        
        controls_layout.addWidget(self.convert_button)
        controls_layout.addWidget(self.stop_convert_button)
        controls_layout.addStretch()
        
        layout.addLayout(controls_layout)
        
        # Progress section
        progress_group = QGroupBox("Conversion Progress")
        progress_layout = QVBoxLayout(progress_group)
        
        self.heic_progress_bar = QProgressBar()
        self.heic_progress_bar.setAccessibleName("Conversion Progress")
        self.heic_progress_bar.setAccessibleDescription("Shows progress of HEIC to JPG conversion")
        progress_layout.addWidget(self.heic_progress_bar)
        
        self.heic_status_label = QLabel("Ready to convert HEIC files")
        self.heic_status_label.setAccessibleName("Conversion Status")
        progress_layout.addWidget(self.heic_status_label)
        
        layout.addWidget(progress_group)
        
        # Results section
        results_group = QGroupBox("Conversion Results")
        results_layout = QVBoxLayout(results_group)
        
        self.heic_results_text = QTextEdit()
        self.heic_results_text.setAccessibleName("Conversion Results")
        self.heic_results_text.setAccessibleDescription("Shows results and status messages from HEIC conversion")
        self.heic_results_text.setReadOnly(True)
        self.heic_results_text.setTabChangesFocus(True)  # Enable Tab navigation
        results_layout.addWidget(self.heic_results_text)
        
        layout.addWidget(results_group)
        
        self.tabs.addTab(tab, "HEIC Conversion")
        
    def create_html_gallery_tab(self):
        """Create the HTML gallery generation tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # File selection section
        file_group = QGroupBox("Description File Selection")
        file_layout = QVBoxLayout(file_group)
        
        # Input file selection
        input_layout = QHBoxLayout()
        self.html_input_path = QLineEdit()
        self.html_input_path.setPlaceholderText("Select image_descriptions.txt file...")
        self.html_input_path.setAccessibleName("Description File Path")
        self.html_input_path.setAccessibleDescription("Path to the image descriptions text file")
        
        self.html_browse_button = QPushButton("Browse...")
        self.html_browse_button.setAccessibleName("Browse for Description File")
        self.html_browse_button.setAccessibleDescription("Click to select the image descriptions file")
        self.html_browse_button.clicked.connect(self.select_html_input_file)
        
        input_layout.addWidget(QLabel("Description File:"))
        input_layout.addWidget(self.html_input_path)
        input_layout.addWidget(self.html_browse_button)
        file_layout.addLayout(input_layout)
        
        # Output file selection
        output_layout = QHBoxLayout()
        self.html_output_path = QLineEdit()
        self.html_output_path.setPlaceholderText("Select output HTML file location...")
        self.html_output_path.setAccessibleName("HTML Output File Path")
        self.html_output_path.setAccessibleDescription("Path where the HTML gallery will be saved")
        
        self.html_output_browse_button = QPushButton("Browse...")
        self.html_output_browse_button.setAccessibleName("Browse for HTML Output")
        self.html_output_browse_button.setAccessibleDescription("Click to select where to save the HTML gallery")
        self.html_output_browse_button.clicked.connect(self.select_html_output_file)
        
        output_layout.addWidget(QLabel("HTML Output:"))
        output_layout.addWidget(self.html_output_path)
        output_layout.addWidget(self.html_output_browse_button)
        file_layout.addLayout(output_layout)
        
        layout.addWidget(file_group)
        
        # HTML options
        options_group = QGroupBox("HTML Options")
        options_layout = QVBoxLayout(options_group)
        
        self.html_full_details = QCheckBox("Include full metadata details")
        self.html_full_details.setAccessibleName("Include Full Details")
        self.html_full_details.setAccessibleDescription("Check to include complete metadata in HTML output")
        options_layout.addWidget(self.html_full_details)
        
        layout.addWidget(options_group)
        
        # Generation controls
        controls_layout = QHBoxLayout()
        
        self.generate_html_button = QPushButton("Generate HTML Gallery")
        self.generate_html_button.setAccessibleName("Generate HTML Gallery")
        self.generate_html_button.setAccessibleDescription("Click to generate HTML gallery from descriptions")
        self.generate_html_button.clicked.connect(self.generate_html_gallery)
        
        self.preview_html_button = QPushButton("Preview HTML")
        self.preview_html_button.setAccessibleName("Preview HTML Gallery")
        self.preview_html_button.setAccessibleDescription("Click to preview the generated HTML gallery in browser")
        self.preview_html_button.clicked.connect(self.preview_html_gallery)
        self.preview_html_button.setEnabled(False)
        
        controls_layout.addWidget(self.generate_html_button)
        controls_layout.addWidget(self.preview_html_button)
        controls_layout.addStretch()
        
        layout.addLayout(controls_layout)
        
        # Status section
        status_group = QGroupBox("Generation Status")
        status_layout = QVBoxLayout(status_group)
        
        self.html_status_label = QLabel("Ready to generate HTML gallery")
        self.html_status_label.setAccessibleName("HTML Generation Status")
        status_layout.addWidget(self.html_status_label)
        
        self.html_results_text = QTextEdit()
        self.html_results_text.setAccessibleName("HTML Generation Results")
        self.html_results_text.setAccessibleDescription("Shows results and status messages from HTML generation")
        self.html_results_text.setReadOnly(True)
        self.html_results_text.setTabChangesFocus(True)  # Enable Tab navigation
        status_layout.addWidget(self.html_results_text)
        
        layout.addWidget(status_group)
        
        self.tabs.addTab(tab, "HTML Gallery")
        
    def create_settings_tab(self):
        """Create the comprehensive settings tab"""
        tab = QWidget()
        
        # Create scroll area for all settings
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        layout = QVBoxLayout(scroll_widget)
        
        # Model Settings Group
        model_group = QGroupBox("Model Settings")
        model_layout = QGridLayout(model_group)
        
        # AI Model selection
        model_layout.addWidget(QLabel("AI Model:"), 0, 0)
        self.model_combo = QComboBox()
        self.model_combo.setAccessibleName("AI Model Selection")
        self.model_combo.setAccessibleDescription("Select the AI model to use for image description")
        self.model_combo.addItems(["moondream", "llama3.2-vision", "llava", "llava:7b"])
        model_layout.addWidget(self.model_combo, 0, 1)
        
        # Temperature
        model_layout.addWidget(QLabel("Temperature:"), 1, 0)
        self.temperature_spin = QSpinBox()
        self.temperature_spin.setRange(0, 100)
        self.temperature_spin.setValue(10)  # 0.1 * 100
        self.temperature_spin.setSuffix(" (0.%02d)")
        self.temperature_spin.setAccessibleName("Temperature")
        self.temperature_spin.setAccessibleDescription("Controls randomness in responses. Lower = more consistent")
        model_layout.addWidget(self.temperature_spin, 1, 1)
        
        # Num Predict
        model_layout.addWidget(QLabel("Max Tokens:"), 2, 0)
        self.num_predict_spin = QSpinBox()
        self.num_predict_spin.setRange(50, 2000)
        self.num_predict_spin.setValue(600)
        self.num_predict_spin.setAccessibleName("Maximum Tokens")
        self.num_predict_spin.setAccessibleDescription("Maximum number of tokens to generate")
        model_layout.addWidget(self.num_predict_spin, 2, 1)
        
        # Top K
        model_layout.addWidget(QLabel("Top K:"), 3, 0)
        self.top_k_spin = QSpinBox()
        self.top_k_spin.setRange(1, 100)
        self.top_k_spin.setValue(40)
        self.top_k_spin.setAccessibleName("Top K")
        self.top_k_spin.setAccessibleDescription("Number of top tokens to consider")
        model_layout.addWidget(self.top_k_spin, 3, 1)
        
        # Top P
        model_layout.addWidget(QLabel("Top P:"), 4, 0)
        self.top_p_spin = QSpinBox()
        self.top_p_spin.setRange(10, 100)
        self.top_p_spin.setValue(90)  # 0.9 * 100
        self.top_p_spin.setSuffix(" (0.%02d)")
        self.top_p_spin.setAccessibleName("Top P")
        self.top_p_spin.setAccessibleDescription("Cumulative probability cutoff")
        model_layout.addWidget(self.top_p_spin, 4, 1)
        
        # Repeat Penalty
        model_layout.addWidget(QLabel("Repeat Penalty:"), 5, 0)
        self.repeat_penalty_spin = QSpinBox()
        self.repeat_penalty_spin.setRange(100, 200)
        self.repeat_penalty_spin.setValue(130)  # 1.3 * 100
        self.repeat_penalty_spin.setSuffix(" (1.%02d)")
        self.repeat_penalty_spin.setAccessibleName("Repeat Penalty")
        self.repeat_penalty_spin.setAccessibleDescription("Penalty for repeating tokens")
        model_layout.addWidget(self.repeat_penalty_spin, 5, 1)
        
        layout.addWidget(model_group)
        
        # Prompt Settings Group
        prompt_group = QGroupBox("Prompt Settings")
        prompt_layout = QVBoxLayout(prompt_group)
        
        # Default Prompt Style
        prompt_style_layout = QHBoxLayout()
        prompt_style_layout.addWidget(QLabel("Default Prompt Style:"))
        self.default_prompt_combo = QComboBox()
        self.default_prompt_combo.addItems(["detailed", "concise", "Narrative", "artistic", "technical", "colorful"])
        self.default_prompt_combo.setAccessibleName("Default Prompt Style")
        self.default_prompt_combo.setAccessibleDescription("Default style used when no specific style is selected")
        prompt_style_layout.addWidget(self.default_prompt_combo)
        prompt_layout.addLayout(prompt_style_layout)
        
        # Custom Prompt Template
        prompt_layout.addWidget(QLabel("Custom Prompt Template:"))
        self.prompt_template_edit = QTextEdit()
        self.prompt_template_edit.setMaximumHeight(100)
        self.prompt_template_edit.setAccessibleName("Custom Prompt Template")
        self.prompt_template_edit.setAccessibleDescription("Main prompt template used for generating descriptions")
        self.prompt_template_edit.setTabChangesFocus(True)  # Enable Tab navigation
        prompt_layout.addWidget(self.prompt_template_edit)
        
        # Prompt Variations Editor
        prompt_layout.addWidget(QLabel("Prompt Variations:"))
        self.prompt_variations_edit = QTextEdit()
        self.prompt_variations_edit.setMaximumHeight(120)
        self.prompt_variations_edit.setAccessibleName("Prompt Variations")
        self.prompt_variations_edit.setAccessibleDescription("JSON format prompt variations for different styles")
        self.prompt_variations_edit.setTabChangesFocus(True)  # Enable Tab navigation
        prompt_layout.addWidget(self.prompt_variations_edit)
        
        layout.addWidget(prompt_group)
        
        # Output Format Settings Group
        output_group = QGroupBox("Output Format Settings")
        output_layout = QGridLayout(output_group)
        
        # Include options
        self.include_timestamp_check = QCheckBox("Include Timestamp")
        self.include_timestamp_check.setAccessibleName("Include Timestamp")
        self.include_timestamp_check.setAccessibleDescription("Include timestamp in output file")
        output_layout.addWidget(self.include_timestamp_check, 0, 0)
        
        self.include_model_info_check = QCheckBox("Include Model Info")
        self.include_model_info_check.setAccessibleName("Include Model Info")
        self.include_model_info_check.setAccessibleDescription("Include model information in output file")
        output_layout.addWidget(self.include_model_info_check, 0, 1)
        
        self.include_file_path_check = QCheckBox("Include File Path")
        self.include_file_path_check.setAccessibleName("Include File Path")
        self.include_file_path_check.setAccessibleDescription("Include full file path in output")
        output_layout.addWidget(self.include_file_path_check, 1, 0)
        
        self.include_metadata_check = QCheckBox("Include Metadata")
        self.include_metadata_check.setAccessibleName("Include Metadata")
        self.include_metadata_check.setAccessibleDescription("Include EXIF metadata from image files")
        output_layout.addWidget(self.include_metadata_check, 1, 1)
        
        # Separator
        separator_layout = QHBoxLayout()
        separator_layout.addWidget(QLabel("Separator Character:"))
        self.separator_edit = QLineEdit()
        self.separator_edit.setMaxLength(5)
        self.separator_edit.setAccessibleName("Separator Character")
        self.separator_edit.setAccessibleDescription("Character used to separate entries in output file")
        separator_layout.addWidget(self.separator_edit)
        output_layout.addLayout(separator_layout, 2, 0, 1, 2)
        
        layout.addWidget(output_group)
        
        # Processing Options Group
        processing_group = QGroupBox("Processing Options")
        processing_layout = QGridLayout(processing_group)
        
        # Max image size
        processing_layout.addWidget(QLabel("Default Max Image Size:"), 0, 0)
        self.default_max_size_spin = QSpinBox()
        self.default_max_size_spin.setRange(256, 4096)
        self.default_max_size_spin.setValue(1024)
        self.default_max_size_spin.setSuffix(" pixels")
        self.default_max_size_spin.setAccessibleName("Default Maximum Image Size")
        self.default_max_size_spin.setAccessibleDescription("Default maximum image dimension in pixels")
        processing_layout.addWidget(self.default_max_size_spin, 0, 1)
        
        # Batch delay
        processing_layout.addWidget(QLabel("Default Batch Delay:"), 1, 0)
        self.default_batch_delay_spin = QSpinBox()
        self.default_batch_delay_spin.setRange(0, 10)
        self.default_batch_delay_spin.setValue(2)
        self.default_batch_delay_spin.setSuffix(" seconds")
        self.default_batch_delay_spin.setAccessibleName("Default Batch Processing Delay")
        self.default_batch_delay_spin.setAccessibleDescription("Default delay between processing images in seconds")
        processing_layout.addWidget(self.default_batch_delay_spin, 1, 1)
        
        # Compression
        self.default_compression_check = QCheckBox("Default Compression Enabled")
        self.default_compression_check.setAccessibleName("Default Compression")
        self.default_compression_check.setAccessibleDescription("Enable image compression by default")
        processing_layout.addWidget(self.default_compression_check, 2, 0)
        
        # Extract metadata
        self.extract_metadata_check = QCheckBox("Extract Metadata")
        self.extract_metadata_check.setAccessibleName("Extract Metadata")
        self.extract_metadata_check.setAccessibleDescription("Extract EXIF metadata from image files")
        processing_layout.addWidget(self.extract_metadata_check, 2, 1)
        
        # Supported formats
        processing_layout.addWidget(QLabel("Supported Formats:"), 3, 0)
        self.supported_formats_edit = QLineEdit()
        self.supported_formats_edit.setAccessibleName("Supported Formats")
        self.supported_formats_edit.setAccessibleDescription("Comma-separated list of supported file extensions")
        processing_layout.addWidget(self.supported_formats_edit, 3, 1)
        
        layout.addWidget(processing_group)
        
        # Available Models Group (Read-only info)
        models_group = QGroupBox("Available Models Information")
        models_layout = QVBoxLayout(models_group)
        
        self.models_info_text = QTextEdit()
        self.models_info_text.setAccessibleName("Available Models Information")
        self.models_info_text.setAccessibleDescription("Information about available AI models")
        self.models_info_text.setReadOnly(True)
        self.models_info_text.setMaximumHeight(150)
        self.models_info_text.setTabChangesFocus(True)  # Enable Tab navigation
        models_layout.addWidget(self.models_info_text)
        
        layout.addWidget(models_group)
        
        # Settings controls
        controls_layout = QHBoxLayout()
        
        self.load_config_button = QPushButton("Load from Config File")
        self.load_config_button.setAccessibleName("Load Configuration")
        self.load_config_button.setAccessibleDescription("Load settings from config.json file")
        self.load_config_button.clicked.connect(self.load_config_file)
        
        self.save_config_button = QPushButton("Save to Config File")
        self.save_config_button.setAccessibleName("Save Configuration")
        self.save_config_button.setAccessibleDescription("Save current settings to config.json file")
        self.save_config_button.clicked.connect(self.save_config_file)
        
        self.reset_config_button = QPushButton("Reset to Defaults")
        self.reset_config_button.setAccessibleName("Reset Configuration")
        self.reset_config_button.setAccessibleDescription("Reset all settings to default values")
        self.reset_config_button.clicked.connect(self.reset_config_file)
        
        controls_layout.addWidget(self.load_config_button)
        controls_layout.addWidget(self.save_config_button)
        controls_layout.addWidget(self.reset_config_button)
        controls_layout.addStretch()
        
        layout.addLayout(controls_layout)
        
        # Set up scroll area
        scroll_area.setWidget(scroll_widget)
        scroll_area.setWidgetResizable(True)
        
        tab_layout = QVBoxLayout(tab)
        tab_layout.addWidget(scroll_area)
        
        self.tabs.addTab(tab, "Settings")
        
        # Don't load config here - will be loaded after all UI is initialized
        
    def setup_accessibility(self):
        """Set up accessibility features"""
        # Set up keyboard shortcuts
        self.setup_keyboard_shortcuts()
        
        # Set focus policies
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        
    def setup_keyboard_shortcuts(self):
        """Set up keyboard shortcuts"""
        # F1 for help
        help_shortcut = QShortcut(QKeySequence.StandardKey.HelpContents, self)
        help_shortcut.activated.connect(self.show_help)
        
        # Ctrl+P for processing
        process_shortcut = QShortcut(QKeySequence("Ctrl+P"), self)
        process_shortcut.activated.connect(self.start_processing)
        
        # Escape to stop processing
        stop_shortcut = QShortcut(QKeySequence("Escape"), self)
        stop_shortcut.activated.connect(self.stop_processing)
        
    def load_model_info(self):
        """Load and display model information"""
        try:
            config_path = Path("config.json")
            if config_path.exists():
                with open(config_path, 'r') as f:
                    config = json.load(f)
                    
                models = config.get('available_models', {})
                info_text = ""
                
                for model_name, model_info in models.items():
                    info_text += f"{model_name}:\n"
                    info_text += f"  Description: {model_info.get('description', 'N/A')}\n"
                    info_text += f"  Size: {model_info.get('size', 'N/A')}\n"
                    info_text += f"  Recommended: {model_info.get('recommended', False)}\n\n"
                    
                self.model_info_text.setPlainText(info_text)
            else:
                self.model_info_text.setPlainText("Config file not found. Using default model settings.")
                
        except Exception as e:
            self.model_info_text.setPlainText(f"Error loading model information: {str(e)}")
            
    def select_image_folder(self):
        """Select folder containing images to process"""
        folder = QFileDialog.getExistingDirectory(
            self, 
            "Select Image Folder",
            "",
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            self.folder_path.setText(folder)
            self.status_bar.showMessage(f"Selected folder: {folder}")
            
    def select_heic_folder(self):
        """Select folder containing HEIC files"""
        folder = QFileDialog.getExistingDirectory(
            self, 
            "Select HEIC Folder",
            "",
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            self.heic_input_path.setText(folder)
            self.status_bar.showMessage(f"Selected HEIC folder: {folder}")
            
    def select_heic_output_folder(self):
        """Select output folder for converted JPG files"""
        folder = QFileDialog.getExistingDirectory(
            self, 
            "Select Output Folder",
            "",
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            self.heic_output_path.setText(folder)
            self.status_bar.showMessage(f"Selected output folder: {folder}")
            
    def select_html_input_file(self):
        """Select input descriptions file for HTML generation"""
        file, _ = QFileDialog.getOpenFileName(
            self,
            "Select Description File",
            "",
            "Text Files (*.txt);;All Files (*)"
        )
        
        if file:
            self.html_input_path.setText(file)
            self.status_bar.showMessage(f"Selected description file: {file}")
            
    def select_html_output_file(self):
        """Select output HTML file location"""
        file, _ = QFileDialog.getSaveFileName(
            self,
            "Save HTML Gallery As",
            "image_descriptions.html",
            "HTML Files (*.html);;All Files (*)"
        )
        
        if file:
            self.html_output_path.setText(file)
            self.status_bar.showMessage(f"HTML output: {file}")
            
    def update_quality_label(self, value):
        """Update the quality label when slider changes"""
        self.quality_label.setText(str(value))
        
    def start_processing(self):
        """Start image processing"""
        folder = self.folder_path.text().strip()
        
        if not folder:
            QMessageBox.warning(self, "Warning", "Please select a folder containing images.")
            return
            
        if not Path(folder).exists():
            QMessageBox.warning(self, "Warning", "Selected folder does not exist.")
            return
            
        # Check if we can find image files
        folder_path = Path(folder)
        pattern = "**/*" if self.recursive_check.isChecked() else "*"
        image_files = []
        
        # Quick check for supported formats
        supported_formats = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp'}
        for file_path in folder_path.glob(pattern):
            if file_path.is_file() and file_path.suffix.lower() in supported_formats:
                image_files.append(file_path)
        
        if not image_files:
            QMessageBox.warning(self, "Warning", "No supported image files found in the selected folder.")
            return
            
        # Check Ollama status
        ollama_status, ollama_message = self.check_ollama_status()
        if not ollama_status:
            QMessageBox.warning(self, "Ollama Status", ollama_message)
            return
        
        # Set up UI for processing
        self.process_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.progress_bar.setValue(0)
        self.results_text.clear()
        self.status_label.setText("Starting image processing...")
        
        # Start processing thread
        self.processing_thread = ProcessingThread(
            folder,
            self.model_combo.currentText(),
            self.default_prompt_combo.currentText(),
            self.recursive_check.isChecked(),
            self.default_max_size_spin.value(),
            self.default_batch_delay_spin.value()
        )
        
        self.processing_thread.progress_updated.connect(self.update_processing_progress)
        self.processing_thread.processing_complete.connect(self.processing_finished)
        self.processing_thread.image_processed.connect(self.image_processing_result)
        
        self.processing_thread.start()
        
    def stop_processing(self):
        """Stop image processing"""
        if self.processing_thread and self.processing_thread.isRunning():
            self.processing_thread.stop()
            self.status_label.setText("Stopping processing...")
            
    def start_heic_conversion(self):
        """Start HEIC to JPG conversion"""
        input_folder = self.heic_input_path.text().strip()
        output_folder = self.heic_output_path.text().strip()
        
        if not input_folder or not output_folder:
            QMessageBox.warning(self, "Warning", "Please select both input and output folders.")
            return
            
        if not Path(input_folder).exists():
            QMessageBox.warning(self, "Warning", "Input folder does not exist.")
            return
            
        # Get HEIC files
        heic_paths = self.get_heic_files(input_folder)
        
        if not heic_paths:
            QMessageBox.warning(self, "Warning", "No HEIC files found in the selected folder.")
            return
            
        # Set up UI for conversion
        self.convert_button.setEnabled(False)
        self.stop_convert_button.setEnabled(True)
        self.heic_progress_bar.setValue(0)
        self.heic_results_text.clear()
        self.heic_status_label.setText("Starting HEIC conversion...")
        
        # Start conversion thread
        self.conversion_thread = HEICConversionThread(
            heic_paths,
            output_folder,
            self.quality_slider.value()
        )
        
        self.conversion_thread.progress_updated.connect(self.update_heic_progress)
        self.conversion_thread.conversion_complete.connect(self.heic_conversion_finished)
        
        self.conversion_thread.start()
        
    def stop_heic_conversion(self):
        """Stop HEIC conversion"""
        if self.conversion_thread and self.conversion_thread.isRunning():
            self.conversion_thread.stop()
            self.heic_status_label.setText("Stopping conversion...")
            
    def generate_html_gallery(self):
        """Generate HTML gallery from descriptions"""
        input_file = self.html_input_path.text().strip()
        output_file = self.html_output_path.text().strip()
        
        if not input_file or not output_file:
            QMessageBox.warning(self, "Warning", "Please select both input and output files.")
            return
            
        if not Path(input_file).exists():
            QMessageBox.warning(self, "Warning", "Input description file does not exist.")
            return
            
        try:
            # Use the HTML converter
            converter = DescriptionsToHTML()
            success = converter.convert_file(
                input_file, 
                output_file, 
                self.html_full_details.isChecked()
            )
            
            if success:
                self.html_status_label.setText("HTML gallery generated successfully!")
                self.html_results_text.append(f"Generated: {output_file}")
                self.preview_html_button.setEnabled(True)
                self.status_bar.showMessage(f"HTML gallery generated: {output_file}")
            else:
                self.html_status_label.setText("HTML generation failed!")
                self.html_results_text.append("Failed to generate HTML gallery.")
                
        except Exception as e:
            self.html_status_label.setText(f"Error: {str(e)}")
            self.html_results_text.append(f"Error generating HTML: {str(e)}")
            
    def preview_html_gallery(self):
        """Preview the generated HTML gallery"""
        output_file = self.html_output_path.text().strip()
        
        if output_file and Path(output_file).exists():
            QDesktopServices.openUrl(QUrl.fromLocalFile(output_file))
        else:
            QMessageBox.warning(self, "Warning", "HTML file not found. Please generate it first.")
            
    def get_image_files(self, folder: str, recursive: bool = False) -> List[str]:
        """Get list of supported image files from folder"""
        image_extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp'}
        image_files = []
        
        folder_path = Path(folder)
        
        if recursive:
            for ext in image_extensions:
                image_files.extend(folder_path.rglob(f'*{ext}'))
                image_files.extend(folder_path.rglob(f'*{ext.upper()}'))
        else:
            for ext in image_extensions:
                image_files.extend(folder_path.glob(f'*{ext}'))
                image_files.extend(folder_path.glob(f'*{ext.upper()}'))
                
        return [str(f) for f in image_files]
        
    def get_heic_files(self, folder: str) -> List[str]:
        """Get list of HEIC files from folder"""
        heic_extensions = {'.heic', '.heif'}
        heic_files = []
        
        folder_path = Path(folder)
        
        for ext in heic_extensions:
            heic_files.extend(folder_path.glob(f'*{ext}'))
            heic_files.extend(folder_path.glob(f'*{ext.upper()}'))
            
        return [str(f) for f in heic_files]
        
    def update_processing_progress(self, progress: int, message: str):
        """Update processing progress"""
        self.progress_bar.setValue(progress)
        self.status_label.setText(message)
        self.status_bar.showMessage(message)
        
    def update_heic_progress(self, progress: int, message: str):
        """Update HEIC conversion progress"""
        self.heic_progress_bar.setValue(progress)
        self.heic_status_label.setText(message)
        self.status_bar.showMessage(message)
        
    def processing_finished(self, success: bool, message: str):
        """Handle processing completion"""
        self.process_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        
        if success:
            self.progress_bar.setValue(100)
            self.status_label.setText("Processing completed successfully!")
            self.results_text.append(f"\n✅ {message}")
        else:
            self.status_label.setText("Processing failed or was cancelled.")
            self.results_text.append(f"\n❌ {message}")
            
        self.status_bar.showMessage(message)
        
    def heic_conversion_finished(self, success: bool, message: str):
        """Handle HEIC conversion completion"""
        self.convert_button.setEnabled(True)
        self.stop_convert_button.setEnabled(False)
        
        if success:
            self.heic_progress_bar.setValue(100)
            self.heic_status_label.setText("Conversion completed successfully!")
            self.heic_results_text.append(f"\n✅ {message}")
        else:
            self.heic_status_label.setText("Conversion failed or was cancelled.")
            self.heic_results_text.append(f"\n❌ {message}")
            
        self.status_bar.showMessage(message)
        
    def image_processing_result(self, filename: str, description: str):
        """Handle individual image processing result"""
        self.results_text.append(f"\n📷 {Path(filename).name}")
        if description and not description.startswith("Failed") and not description.startswith("Error"):
            # Show first 100 characters of description
            self.results_text.append(f"   ✅ {description[:100]}...")
        else:
            self.results_text.append(f"   ❌ {description}")
        
        # Scroll to bottom
        cursor = self.results_text.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.results_text.setTextCursor(cursor)
            
    def load_settings(self):
        """Load settings with hierarchy: hard-coded defaults → config.json → QSettings (Registry)"""
        # Load window geometry from QSettings
        geometry = self.settings.value('geometry')
        if geometry:
            self.restoreGeometry(geometry)
            
        # Load configuration defaults from config.json
        config_defaults = self.load_config_defaults()
        
        # Load settings with hierarchy: config.json defaults, then QSettings overrides
        self.model_combo.setCurrentText(
            self.settings.value('model', config_defaults.get('default_model', 'moondream'))
        )
        self.default_prompt_combo.setCurrentText(
            self.settings.value('prompt_style', config_defaults.get('default_prompt_style', 'detailed'))
        )
        self.recursive_check.setChecked(
            self.settings.value('recursive', False, type=bool)
        )
        self.default_max_size_spin.setValue(
            self.settings.value('max_size', config_defaults.get('default_max_image_size', 1024), type=int)
        )
        self.default_batch_delay_spin.setValue(
            self.settings.value('batch_delay', config_defaults.get('default_batch_delay', 2), type=int)
        )
        self.quality_slider.setValue(
            self.settings.value('jpeg_quality', 95, type=int)
        )
        self.html_full_details.setChecked(
            self.settings.value('html_full_details', False, type=bool)
        )
        
        # Update quality label
        self.update_quality_label(self.quality_slider.value())
        
    def save_settings(self):
        """Save settings to QSettings (Registry) - user session preferences"""
        # Save window geometry
        self.settings.setValue('geometry', self.saveGeometry())
        
        # Save user preferences that override config.json
        self.settings.setValue('model', self.model_combo.currentText())
        self.settings.setValue('prompt_style', self.default_prompt_combo.currentText())
        self.settings.setValue('recursive', self.recursive_check.isChecked())
        self.settings.setValue('max_size', self.default_max_size_spin.value())
        self.settings.setValue('batch_delay', self.default_batch_delay_spin.value())
        self.settings.setValue('jpeg_quality', self.quality_slider.value())
        self.settings.setValue('html_full_details', self.html_full_details.isChecked())
        
        # Update immediately
        self.settings.sync()
        
    def load_config_defaults(self):
        """Load default settings from config.json with hard-coded fallbacks"""
        defaults = {
            'default_model': 'moondream',
            'default_prompt_style': 'detailed',
            'default_max_image_size': 1024,
            'default_batch_delay': 2,
            'temperature': 0.1,
            'num_predict': 600,
            'top_k': 40,
            'top_p': 0.9,
            'repeat_penalty': 1.3,
            'include_timestamp': True,
            'include_model_info': True,
            'include_file_path': True,
            'include_metadata': True,
            'separator': '---',
            'default_compression': True,
            'extract_metadata': True,
            'supported_formats': ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'webp', 'heic']
        }
        
        try:
            config_path = Path("config.json")
            if config_path.exists():
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    
                # Update defaults with config.json values
                model_settings = config.get('model_settings', {})
                processing_options = config.get('processing_options', {})
                output_format = config.get('output_format', {})
                
                # Override defaults with config values
                if 'default_model' in config:
                    defaults['default_model'] = config['default_model']
                if 'default_prompt_style' in config:
                    defaults['default_prompt_style'] = config['default_prompt_style']
                    
                # Model settings
                defaults.update({
                    'temperature': model_settings.get('temperature', defaults['temperature']),
                    'num_predict': model_settings.get('num_predict', defaults['num_predict']),
                    'top_k': model_settings.get('top_k', defaults['top_k']),
                    'top_p': model_settings.get('top_p', defaults['top_p']),
                    'repeat_penalty': model_settings.get('repeat_penalty', defaults['repeat_penalty'])
                })
                
                # Processing options
                defaults.update({
                    'default_max_image_size': processing_options.get('default_max_image_size', defaults['default_max_image_size']),
                    'default_batch_delay': processing_options.get('default_batch_delay', defaults['default_batch_delay']),
                    'default_compression': processing_options.get('default_compression', defaults['default_compression']),
                    'extract_metadata': processing_options.get('extract_metadata', defaults['extract_metadata'])
                })
                
                # Output format
                defaults.update({
                    'include_timestamp': output_format.get('include_timestamp', defaults['include_timestamp']),
                    'include_model_info': output_format.get('include_model_info', defaults['include_model_info']),
                    'include_file_path': output_format.get('include_file_path', defaults['include_file_path']),
                    'include_metadata': output_format.get('include_metadata', defaults['include_metadata']),
                    'separator': output_format.get('separator', defaults['separator'])
                })
                
                # Supported formats
                if 'supported_formats' in processing_options:
                    defaults['supported_formats'] = processing_options['supported_formats']
                    
        except (FileNotFoundError, json.JSONDecodeError, KeyError) as e:
            # Use hard-coded defaults if config.json has issues
            pass
        except Exception as e:
            # Use hard-coded defaults for any other errors
            pass
            
        return defaults
        
    def reset_settings(self):
        """Reset QSettings to use config.json defaults"""
        config_defaults = self.load_config_defaults()
        
        reply = QMessageBox.question(
            self, 
            "Reset Settings", 
            "Are you sure you want to reset user preferences? This will use the config.json defaults.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Clear all QSettings so config.json defaults are used
            self.settings.clear()
            self.settings.sync()
            
            # Reload the UI with the config defaults
            self.load_settings()
            
            QMessageBox.information(self, "Settings", "User preferences reset to config.json defaults!")
            
    def show_about(self):
        """Show about dialog"""
        about_text = """
        <h3>Image Description Toolkit</h3>
        <p>Version 1.0</p>
        <p>A comprehensive GUI application for AI-powered image analysis using Ollama vision models.</p>
        
        <h4>Features:</h4>
        <ul>
        <li>AI-powered image descriptions</li>
        <li>HEIC to JPG conversion</li>
        <li>HTML gallery generation</li>
        <li>Batch processing</li>
        <li>Full accessibility support</li>
        </ul>
        
        <p>Built with PyQt6 for Windows accessibility and modern UI design.</p>
        """
        
        QMessageBox.about(self, "About Image Description Toolkit", about_text)
        
    def show_help(self):
        """Show help dialog"""
        help_text = """
        <h3>Help - Image Description Toolkit</h3>
        
        <h4>Getting Started:</h4>
        <ol>
        <li>Ensure Ollama is installed and running</li>
        <li>Install a vision model: <code>ollama pull moondream</code></li>
        <li>Use the tabs to access different features</li>
        </ol>
        
        <h4>Keyboard Shortcuts:</h4>
        <ul>
        <li><b>Ctrl+O</b>: Open folder</li>
        <li><b>Ctrl+P</b>: Start processing</li>
        <li><b>Escape</b>: Stop processing</li>
        <li><b>F1</b>: Show this help</li>
        </ul>
        
        <h4>Accessibility:</h4>
        <p>This application is designed for full accessibility with screen readers, keyboard navigation, and high contrast support.</p>
        """
        
        QMessageBox.information(self, "Help", help_text)
        
    def closeEvent(self, event):
        """Handle application close event"""
        # Save window geometry and final settings
        self.settings.setValue('geometry', self.saveGeometry())
        self.settings.sync()
        
        # Stop any running threads
        if self.processing_thread and self.processing_thread.isRunning():
            self.processing_thread.stop()
            self.processing_thread.wait(5000)  # Wait up to 5 seconds
            
        if self.conversion_thread and self.conversion_thread.isRunning():
            self.conversion_thread.stop()
            self.conversion_thread.wait(5000)  # Wait up to 5 seconds
            
        event.accept()
    
    def check_ollama_status(self):
        """Check if Ollama is running and accessible"""
        try:
            import ollama
            
            # Try to list models
            response = ollama.list()
            
            # Handle different response formats
            if hasattr(response, 'models'):
                # New Ollama client returns an object with .models attribute
                models_list = response.models
            elif isinstance(response, dict):
                models_list = response.get('models', [])
            elif isinstance(response, list):
                models_list = response
            else:
                # Try to convert to dict if it has model-like attributes
                try:
                    models_list = getattr(response, 'models', [])
                except AttributeError:
                    return False, f"Unexpected response format from Ollama: {type(response)}. Try updating ollama package."
            
            # Extract model names safely
            available_models = []
            for model in models_list:
                model_name = None
                
                # Handle different model object types
                if hasattr(model, 'name'):
                    model_name = model.name
                elif hasattr(model, 'model'):
                    model_name = model.model
                elif isinstance(model, dict):
                    model_name = model.get('name') or model.get('model') or model.get('id')
                elif isinstance(model, str):
                    model_name = model
                
                if model_name:
                    available_models.append(model_name)
            
            if not available_models:
                return False, "No models installed in Ollama. Install a vision model with: ollama pull moondream"
            
            # Check if selected model is available
            selected_model = self.model_combo.currentText()
            
            # Check for exact match or partial match
            model_found = False
            for model in available_models:
                if selected_model == model or selected_model in model:
                    model_found = True
                    break
            
            if not model_found:
                return False, f"Model '{selected_model}' not found. Available models: {', '.join(available_models)}"
            
            return True, f"Ollama is running with {len(available_models)} models"
            
        except ImportError:
            return False, "Ollama Python package not installed. Install with: pip install ollama"
        except Exception as e:
            return False, f"Ollama connection error: {str(e)}. Ensure Ollama is running."
    
    def load_config_to_ui(self):
        """Load configuration with hierarchy: hard-coded defaults → config.json → QSettings (Registry)"""
        # Get defaults from config.json with hard-coded fallbacks
        config_defaults = self.load_config_defaults()
        
        # Load settings UI elements if they exist (Settings tab)
        if hasattr(self, 'temperature_spin'):
            temp_value = config_defaults.get('temperature', 0.1)
            self.temperature_spin.setValue(int(temp_value * 100))
        if hasattr(self, 'num_predict_spin'):
            self.num_predict_spin.setValue(int(config_defaults.get('num_predict', 600)))
        if hasattr(self, 'top_k_spin'):
            self.top_k_spin.setValue(int(config_defaults.get('top_k', 40)))
        if hasattr(self, 'top_p_spin'):
            top_p_value = config_defaults.get('top_p', 0.9)
            self.top_p_spin.setValue(int(top_p_value * 100))
        if hasattr(self, 'repeat_penalty_spin'):
            penalty_value = config_defaults.get('repeat_penalty', 1.3)
            self.repeat_penalty_spin.setValue(int(penalty_value * 100))
        
        # Prompt settings
        if hasattr(self, 'default_prompt_combo'):
            self.default_prompt_combo.setCurrentText(config_defaults.get('default_prompt_style', 'detailed'))
        if hasattr(self, 'prompt_template_edit'):
            # Try to load from config.json
            try:
                config_path = Path("config.json")
                if config_path.exists():
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        self.prompt_template_edit.setPlainText(config.get('prompt_template', ''))
                else:
                    self.prompt_template_edit.setPlainText('')
            except:
                self.prompt_template_edit.setPlainText('')
        
        # Format prompt variations as JSON for editing
        if hasattr(self, 'prompt_variations_edit'):
            try:
                config_path = Path("config.json")
                if config_path.exists():
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        prompt_variations = config.get('prompt_variations', {})
                        self.prompt_variations_edit.setPlainText(json.dumps(prompt_variations, indent=2))
                else:
                    self.prompt_variations_edit.setPlainText('{}')
            except:
                self.prompt_variations_edit.setPlainText('{}')
        
        # Output format
        if hasattr(self, 'include_timestamp_check'):
            self.include_timestamp_check.setChecked(config_defaults.get('include_timestamp', True))
        if hasattr(self, 'include_model_info_check'):
            self.include_model_info_check.setChecked(config_defaults.get('include_model_info', True))
        if hasattr(self, 'include_file_path_check'):
            self.include_file_path_check.setChecked(config_defaults.get('include_file_path', True))
        if hasattr(self, 'include_metadata_check'):
            self.include_metadata_check.setChecked(config_defaults.get('include_metadata', True))
        if hasattr(self, 'separator_edit'):
            self.separator_edit.setText(config_defaults.get('separator', '---'))
        
        # Processing options
        if hasattr(self, 'default_max_size_spin'):
            self.default_max_size_spin.setValue(int(config_defaults.get('default_max_image_size', 1024)))
        if hasattr(self, 'default_batch_delay_spin'):
            self.default_batch_delay_spin.setValue(int(config_defaults.get('default_batch_delay', 2)))
        if hasattr(self, 'default_compression_check'):
            self.default_compression_check.setChecked(config_defaults.get('default_compression', True))
        if hasattr(self, 'extract_metadata_check'):
            self.extract_metadata_check.setChecked(config_defaults.get('extract_metadata', True))
        
        # Supported formats
        if hasattr(self, 'supported_formats_edit'):
            supported_formats = config_defaults.get('supported_formats', [])
            self.supported_formats_edit.setText(', '.join(supported_formats))
        
        # Available models info
        if hasattr(self, 'models_info_text'):
            try:
                config_path = Path("config.json")
                if config_path.exists():
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        available_models = config.get('available_models', {})
                        models_text = "Available Models:\n"
                        for model_name, model_info in available_models.items():
                            models_text += f"• {model_name}: {model_info.get('description', 'No description')}\n"
                        self.models_info_text.setPlainText(models_text)
                else:
                    self.models_info_text.setPlainText("No config.json file found. Using default model settings.")
            except:
                self.models_info_text.setPlainText("Error loading model information from config.json.")
    
    def save_config_file(self):
        """Save current UI settings to config.json"""
        try:
            # Only proceed if we have the new UI elements
            if not hasattr(self, 'temperature_spin'):
                QMessageBox.warning(self, "Configuration", "Advanced settings not available in this interface.")
                return
                
            # Load existing config or create new one
            config = {}
            try:
                with open('config.json', 'r') as f:
                    config = json.load(f)
            except FileNotFoundError:
                pass
            
            # Update model settings
            config['model_settings'] = {
                'temperature': self.temperature_spin.value() / 100.0,
                'num_predict': self.num_predict_spin.value(),
                'top_k': self.top_k_spin.value(),
                'top_p': self.top_p_spin.value() / 100.0,
                'repeat_penalty': self.repeat_penalty_spin.value() / 100.0
            }
            
            # Update prompt settings
            config['default_prompt_style'] = self.default_prompt_combo.currentText()
            config['prompt_template'] = self.prompt_template_edit.toPlainText()
            
            # Parse prompt variations JSON
            try:
                prompt_variations_text = self.prompt_variations_edit.toPlainText()
                if prompt_variations_text.strip():
                    config['prompt_variations'] = json.loads(prompt_variations_text)
            except json.JSONDecodeError:
                QMessageBox.warning(self, "Configuration", "Invalid JSON in prompt variations. This section will not be saved.")
            
            # Update output format
            config['output_format'] = {
                'include_timestamp': self.include_timestamp_check.isChecked(),
                'include_model_info': self.include_model_info_check.isChecked(),
                'include_file_path': self.include_file_path_check.isChecked(),
                'include_metadata': self.include_metadata_check.isChecked(),
                'separator': self.separator_edit.text()
            }
            
            # Update processing options
            if 'processing_options' not in config:
                config['processing_options'] = {}
            
            config['processing_options']['default_max_image_size'] = self.default_max_size_spin.value()
            config['processing_options']['default_batch_delay'] = self.default_batch_delay_spin.value()
            config['processing_options']['default_compression'] = self.default_compression_check.isChecked()
            config['processing_options']['extract_metadata'] = self.extract_metadata_check.isChecked()
            
            # Parse supported formats
            formats_text = self.supported_formats_edit.text()
            if formats_text.strip():
                config['processing_options']['supported_formats'] = [
                    fmt.strip() for fmt in formats_text.split(',') if fmt.strip()
                ]
            
            # Save to file
            with open('config.json', 'w') as f:
                json.dump(config, f, indent=2)
            
            QMessageBox.information(self, "Configuration", "Settings saved successfully to config.json")
            
        except Exception as e:
            QMessageBox.critical(self, "Configuration", f"Error saving configuration: {str(e)}")
    
    def load_config_file(self):
        """Reload configuration from config.json"""
        try:
            # Reload the configuration to UI
            self.load_config_to_ui()
            
            # Also reload the main settings to pick up any changes
            self.load_settings()
            
            if hasattr(self, 'temperature_spin'):
                QMessageBox.information(self, "Configuration", "Configuration reloaded from config.json")
            else:
                QMessageBox.information(self, "Configuration", "Configuration reloaded from config.json")
        except Exception as e:
            QMessageBox.warning(self, "Configuration", f"Error loading configuration: {str(e)}")
    
    def reset_config_file(self):
        """Reset all settings to hard-coded default values"""
        if not hasattr(self, 'temperature_spin'):
            QMessageBox.warning(self, "Configuration", "Advanced settings not available in this interface.")
            return
            
        reply = QMessageBox.question(
            self, "Reset Configuration", 
            "Are you sure you want to reset all settings to hard-coded default values?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Set hard-coded default values
            self.temperature_spin.setValue(10)  # 0.1
            self.num_predict_spin.setValue(600)
            self.top_k_spin.setValue(40)
            self.top_p_spin.setValue(90)  # 0.9
            self.repeat_penalty_spin.setValue(130)  # 1.3
            
            self.default_prompt_combo.setCurrentText('detailed')
            self.prompt_template_edit.clear()
            self.prompt_variations_edit.setPlainText('{}')
            
            self.include_timestamp_check.setChecked(True)
            self.include_model_info_check.setChecked(True)
            self.include_file_path_check.setChecked(True)
            self.include_metadata_check.setChecked(True)
            self.separator_edit.setText('---')
            
            self.default_max_size_spin.setValue(1024)
            self.default_batch_delay_spin.setValue(2)
            self.default_compression_check.setChecked(True)
            self.extract_metadata_check.setChecked(True)
            self.supported_formats_edit.setText('jpg, jpeg, png, gif, bmp, tiff, webp, heic')
            
            # Reset main UI elements to defaults
            self.model_combo.setCurrentText('moondream')
            self.default_prompt_combo.setCurrentText('detailed')
            self.recursive_check.setChecked(False)
            self.default_max_size_spin.setValue(1024)
            self.default_batch_delay_spin.setValue(2)
            self.quality_slider.setValue(95)
            self.html_full_details.setChecked(False)
            
            QMessageBox.information(self, "Configuration", "All settings reset to hard-coded default values")
    
def main():
    """Main application entry point"""
    app = QApplication(sys.argv)
    
    # Set application properties
    app.setApplicationName("Image Description Toolkit")
    app.setApplicationVersion("1.0")
    app.setOrganizationName("Image Description Toolkit")
    app.setOrganizationDomain("imageDescriptionToolkit.local")
    
    # Create and show main window
    window = ImageDescriptionGUI()
    window.show()
    
    # Run the application
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
